<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Functions</title>
</head>
<body>
    <script>
        // 1. Function Declaration
        function greet(name) {
            return `Hello, ${name}!`;
        }
        console.log(greet('Alice')); // Output: Hello, Alice!

        // Explanation: This is a traditional way of defining a function using the 'function' keyword. The function can be called before or after its declaration.

        // 2. Function Expression
        const sum = function(a, b) {
            return a + b;
        };
        console.log(sum(5, 3)); // Output: 8

        // Explanation: This is a function expression where a function is assigned to a variable. The function is called using the variable name.

        // 3. Arrow Function
        const multiply = (a, b) => a * b;
        console.log(multiply(4, 7)); // Output: 28

        // Explanation: Arrow functions provide a shorter syntax and do not have their own 'this' context.

        // 4. Immediately Invoked Function Expression (IIFE)
        (function() {
            console.log('This function runs immediately!');
        })(); // Output: This function runs immediately!

        // Explanation: An IIFE is a function that runs as soon as it is defined. It helps in avoiding polluting the global scope.

        // 5. Higher-Order Function
        function map(array, fn) {
            const result = [];
            for (let i = 0; i < array.length; i++) {
                result.push(fn(array[i]));
            }
            return result;
        }
        const numbers = [1, 2, 3, 4];
        const squares = map(numbers, num => num * num);
        console.log(squares); // Output: [1, 4, 9, 16]

        // Explanation: A higher-order function is a function that takes another function as an argument or returns a function as a result.

        // 6. Callback Function
        function fetchData(callback) {
            setTimeout(() => {
                const data = 'Sample Data';
                callback(data);
            }, 2000);
        }
        fetchData(function(data) {
            console.log(data); // Output: Sample Data (after 2 seconds)
        });

        // Explanation: A callback function is passed as an argument to another function and is executed after some operation is completed.

        // 7. Recursive Function
        function factorial(n) {
            if (n === 0) {
                return 1;
            }
            return n * factorial(n - 1);
        }
        console.log(factorial(5)); // Output: 120

        // Explanation: A recursive function is a function that calls itself until it reaches a base condition.

        // 8. Asynchronous Function (using async/await)
        async function fetchUserData() {
            const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
            const data = await response.json();
            console.log(data);
        }
        fetchUserData();

        // Explanation: An asynchronous function allows the use of 'await' inside it to wait for asynchronous operations to complete. It helps in writing cleaner asynchronous code.
    </script>
</body>
</html>